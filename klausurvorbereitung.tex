\documentclass[
  a4paper,
  11pt,
]{scrartcl}

\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage[
  cm,
  headings
]{fullpage}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
% Für die Klammern der Interpretationsabbildung:
\usepackage{stmaryrd}

\usepackage{color}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{myblue}{rgb}{0,0,0.8}
\definecolor{myred}{rgb}{0.8,0,0}
\definecolor{mygreen}{rgb}{0,0.6,0}

\usepackage[
  colorlinks=true,
  linkcolor=myblue,
]{hyperref}

% Coole Zeichnungen:
\usepackage{tikz}
\tikzstyle{vertex}=[draw, circle, minimum size=20pt]
\tikzstyle{edge}=[draw, -]
\usetikzlibrary{%
  %backgrounds,
  %mindmap,
  %shapes.geometric,
  %shapes.symbols,
  %shapes.misc,
  %shapes.multipart,
  positioning,
  %fit,
  %calc,
  %arrows,
  automata,
  %trees,
  %decorations.pathreplacing,
}

\usepackage{pgfplots}

% Für Zeilenumbrüche ohne Indentations
\setlength{\parindent}{0pt}

\usepackage{listings}
\lstset{%
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{mygray},
  language=C,
  showstringspaces=false,
}

\usepackage{enumerate}
% Schönere Tabellen
% dazu gibt’s neue Kommandos:
% - \toprule[(Dicke)], \midrule[(Dicke)], \bottomrule[(Dicke)]
% - \addlinespace: Extrahöhe zwischen Zeilen
\usepackage{booktabs}
% um in Tabellen eine Zelle über mehrere Zeilen laufen zu lassen:
\usepackage{multirow}

\usepackage{algorithmic}
\renewcommand{\algorithmicrequire}{\textbf{Eingabe:}}

\usepackage{bussproofs}

% coole Kopf- und Fußzeilen:
\usepackage{fancyhdr}
% Seitenstil ist natürlich fancy:
\pagestyle{fancy}
% alle Felder löschen:
\fancyhf{}

%\fancyhead[L]{
%}
%\fancyhead[R]{%
%}
%\fancyfoot[L]{}

\fancyfoot[C]{\thepage}

% Linien oben/unten entfernen:
\renewcommand{\headrulewidth}{0.0pt}
\renewcommand{\footrulewidth}{0.0pt}

\allowdisplaybreaks{}

\title{Klausurvorbereitung: Theoretische Informatik}

\subtitle{Universität Rostock}

%\author{%
%}

\date{}

\newcommand{\p}{\leq_{\textsf{p}}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\Ac}{\mathcal{A}}
\newcommand{\Bc}{\mathcal{B}}
\newcommand{\Cc}{\mathcal{C}}
\newcommand{\Dc}{\mathcal{D}}
\newcommand{\Kc}{\mathcal{K}}
\newcommand{\Nc}{\mathcal{N}}
\newcommand{\Rc}{\mathcal{R}}
\newcommand{\Sc}{\mathcal{S}}
\newcommand{\Tc}{\mathcal{T}}
\newcommand{\Vc}{\mathcal{V}}
\newcommand{\Zc}{\mathcal{Z}}
\renewcommand{\ae}{\leq_{\textsf{ae}}}

\newcommand{\COLOR}{\textsf{COLOR}}
\newcommand{\COLORDrei}{\textsf{COLOR-3}}
\newcommand{\DreiSAT}{\textsf{3SAT}}
\newcommand{\bin}{\text{bin}}
\newcommand{\TSP}{\textsf{TSP}}
\newcommand{\HC}{\textsf{HAMILTONIAN CIRCUIT}}
\newcommand{\TSPOPTI}{\textsf{TSP\_OPT\_1}}
\newcommand{\NELP}{\textsf{0--1 LINEAR PROGRAMMING}}
\newcommand{\CLIQUE}{\textsf{CLIQUE}}
\newcommand{\NP}{\textsf{NP}}
\newcommand{\id}{\text{id}}
\newcommand{\IS}{\textsf{INDEPENDENT SET}}
\newcommand{\VC}{\textsf{VERTEX COVER}}
\newcommand{\IV}{\textsf{INTERESSENVERTRETER}}
\newcommand{\wpc}{\textit{wp}}

\newcommand{\prightarrow}{\ {}_p\!\!\rightarrow}

\begin{document}

\maketitle

\tableofcontents

\section{Themen \& Inhalte}
\label{sec:themen}

\subsection{Komplexität und formale Sprachen}
\label{sub:themen_inhalte_komplexitat_und_formale_sprachen}

\begin{itemize}
  \item \NP-Vollständigkeit durch Polynomialreduktion zeigen
    \begin{itemize}
      \item Bsp: $\DreiSAT \p \IS$
    \end{itemize}
  \item Zeigen, dass eine Sprache nicht regulär ist (Pumping-Lemma für reguläre
    Sprachen)
    \begin{itemize}
      \item Bsp: $L = \{ 0^n 1^n \mid n \in \N \}$ ist nicht regulär

        \includegraphics[width=0.9\textwidth]{bilder/0n1n_ist_nicht_regulaer.jpg}
    \end{itemize}
  \item Turing-Maschine bauen (deterministisch und nichtdeterministisch)
    \begin{itemize}
      \item Bsp: eine NTM mit $\Sigma = \{\Box, 0, 1\}$, die zwei Einsen auf dem
        Band erkennt (Startposition ist beliebig)
    \end{itemize}
  \item Mengenschreibweise einer Sprache aus einer gegebenen Grammatik angeben
    \begin{itemize}
      \item siehe Serie 8, Aufgabe 3 und Aufgabe 4
    \end{itemize}
  \item nicht-/deterministischen endlichen Automaten aus einer gegebenen
    Grammatik konstruieren
    \begin{itemize}
      \item siehe Serie 8, Aufgabe 3 und Aufgabe 4
      \item dazu gehört auch: eine rechtslineare Grammatik normalisieren
    \end{itemize}
  \item deterministischen endlichen Automaten minimieren
    \begin{itemize}
      \item siehe Serie 9, Aufgabe 3
      \item siehe \hyperref[sub:serie_10]{Serie 10},
        \hyperref[kfs_serie_10_aufgabe_1]{Aufgabe 1}
      \item weiteres Beispiel:

        \includegraphics[width=0.9\textwidth]{bilder/dea_minimieren.jpg}
    \end{itemize}
  \item Pumpingzahl einer regulären Sprache angeben
    \begin{itemize}
      \item siehe \hyperref[sub:serie_10]{Serie 10},
        \hyperref[kfs_serie_10_aufgabe_2_c]{Aufgabe 2 (c)}
    \end{itemize}
  \item NDEA $\rightarrow$ DEA
    \begin{itemize}
      \item siehe Serie 9, Aufgabe 1
      \item siehe auch das Beispiel aus~\cite{hopcroft2011}:

        \includegraphics[width=0.9\textwidth]{bilder/ndea_zu_dea_bsp_aus_hopcroft.jpg}
    \end{itemize}
\end{itemize}

\subsection{Semantik}
\label{sub:themen_inhalte_semantik}

\subsubsection{Induktion}
\label{ssub:Induktion}

\paragraph{Strukturelle Induktion}
\label{par:strukturelle_induktion}

\begin{itemize}
  \item Bildungsregeln: eine Bildungsregel über einer beliebigen Menge $M$ ist
    ein Paar $(V, e)$ aus einer endlichen Menge $V \sqsubseteq M$, der
    sogenannten Regel-Voraussetzung, und einem Element $e \in M$, dem
    sogenannten Erzeugnis der Regel.

    Eine Regel $(\emptyset, e)$ mit leerer Regel-Voraussetzung nennen wir eine
    Verankerung. Eine Regel $(V, e)$ mit nicht-leerer Regel-Voraussetzung $V
    \neq \emptyset$ nennen wir einen Schritt.

    Die Anwendung der einzelnen Regel $(V, e)$ auf eine Teilmenge $T \subseteq
    M$ ist wieder eine Teilmenge von $M$. Sie ist definiert durch:
    \begin{align*}
      \alpha( \, (V, e), T) :=
      \begin{cases}
        \{ e \} & \text{falls } V \subseteq T\\
        \emptyset & \text{falls } V \subsetneq T
      \end{cases}
    \end{align*}

    Die Anwendung der Regelmenge $\Rc$ auf die Teilmenge $T$ ist wieder eine
    Teilmenge von $M$. Sie ist definiert durch:
    \begin{align*}
      \alpha_{\Rc}(T) := \bigcup\limits_{r \in \Rc} \alpha(r, T)
    \end{align*}

    Die Erweiterung der Teilmenge $T$ durch einmalige Anwendung der Regelmenge
    $\Rc$ ist gegeben durch:
    \begin{align*}
      \sigma_{\Rc}(T) := T \cup \alpha_{\Rc}(T)
    \end{align*}

    Eine Teilmenge $T \subseteq M$ heißt $\Rc$-abgeschlossen unter einer Menge
    $\Rc$ von Regeln, wenn gilt: für jede Regel $(V, e) \in \Rc$ gilt: falls die
    Voraussetzungen der Regel in der Menge $T$ enthalten sind, dann ist auch das
    Erzeugnis $e$ der Regel in der Menge $T$ enthalten:
    \begin{align*}
      \forall (V, e) \in \Rc: V \subseteq T \Rightarrow e \in T
    \end{align*}
\end{itemize}

\subsubsection{Formale Ausdrücke}
\label{ssub:formale_ausdruecke}

\paragraph{Zustände}
\label{par:zustande}

\begin{itemize}
  \item Zustände: sei \textbf{Var} eine Menge von Variablen und \textbf{Val}
    eine Menge von Werten. Ein Zustand ist eine partielle Funktion $s:
    \textbf{Var} \rightharpoonup \textbf{Val}$.

  \item Notation von Zuständen: der Zustand $s: \textbf{Var} \rightharpoonup
    \textbf{Val}$ mit $\Dc(s) = \{x_1, x_2, \dots, x_n\}$ und $s(x_i) =
    w_i$ wird auch als $[x_1 \mapsto w_1, \dots, x_n \mapsto w_n]$ notiert.

  \item Die Erweiterung des Zustands $s_1: \textbf{Var} \rightharpoonup
    \textbf{Val}$ um den Zustand $s_2: \textbf{Var} \rightharpoonup
    \textbf{Val}$ ist definiert als
    \begin{align*}
      s_1 \oplus s_1: & \textbf{Var} \rightharpoonup \textbf{Val}\\
      & v \mapsto (s_1 \oplus s_2)(v) :=
        \begin{cases}
          s_2(v), & \Leftrightarrow v \in \Dc(s_2)\\
          s_1(v), & \Leftrightarrow v \in \Dc(s_1)
            \land v \notin \Dc(s_2)\\
        \end{cases}
    \end{align*}

    Bei einer Erweiterung wird ein Zustand also von links nach rechts
    „überschrieben“.

    Für eine abstrakte Menge von Zuständen schreiben wir neben $\textbf{Var}
    \rightharpoonup \textbf{Val}$ gelegentlich auch $\Zc$.
\end{itemize}

\paragraph{Interpretation}
\label{par:interpretation}

\begin{itemize}
  \item Interpretationsfunktion:
    \begin{align*}
      \llbracket \ \rrbracket:
        \textbf{Exp} \rightarrow
          \Big[ \,
            \big[
              \underbrace{\textbf{Var} \rightarrow \N_0}_{\text{Zustand}}
            \big]
            \rightarrow
            \underbrace{\N_0}_{\text{Wert}}
          \Big]
    \end{align*}
    oder allgemein:
    \begin{align*}
      \llbracket \ \rrbracket:
        \textbf{Exp} \rightarrow
          \Big[ \,
            \big[
              \underbrace{\textbf{Var} \rightarrow \textbf{Val}}_{\text{Zustand}}
            \big]
            \rightarrow
            \underbrace{\textbf{Val}}_{\text{Wert}}
          \Big]
    \end{align*}
    oder:
    \begin{align*}
      \llbracket \ \rrbracket:
        \textbf{Exp} \rightarrow
          \left[\Zc \rightarrow \textbf{Val} \right]
    \end{align*}

  \item Die Interpretation eines Ausdrucks, der nur aus der Variable $x$
    besteht, ist $\llbracket x \rrbracket$. Das ist nach Definition eine
    Funktion $\left[ \textbf{Var} \rightarrow \N_0 \right] \rightarrow \N_0$.
    Für jeden Zustand $\sigma: \textbf{Var} \rightarrow \textbf{Val}$ ist somit
    $\llbracket x \rrbracket (\sigma)$ eine natürliche Zahl. Es ist naheliegend,
    hier $\llbracket x \rrbracket (\sigma) = \sigma(x)$ zu fordern: die
    Bedeutung $\llbracket x \rrbracket (\sigma)$ einer Variablen $x$ (als
    Ausdruck) in einem Zustand $\sigma$ ist durch den Wert $\sigma(x)$ der
    Variablen in diesem Zustand gegeben.
\end{itemize}

\subsubsection{Ersetzungs-Systeme}
\label{ssub:Ersetzungs-Systeme}

\paragraph{Allgemeine Ersetzungs-Systeme}
\label{par:allgemeine_ersetzungs_systeme}

\begin{itemize}
  \item Ein Ersetzungs-System (rewriting system) ist ein Paar $(M, \rightarrow)$
    bestehend aus
    \begin{enumerate}
      \item einer Menge $M$, der sogenannten Basismenge, und
      \item einer binären Relation $\rightarrow \ \subseteq M \times M$ auf $M$,
        die Reduktions-Relation genannt wird.
    \end{enumerate}
    Gilt $(a, b) \in \ \rightarrow$ so schreibt man auch $a \rightarrow b$ und
    sagt, dass $a$ zu $b$ (unmittelbar) reduziert.

  \item abgeleitete Relationen:
    \begin{itemize}
      \item transitive Reduktions-Relation
      \item reflexiv-transitive Reduktions-Relation
      \item symmetrische Reduktions-Relation
      \item symmetrisch-transitive Reduktions-Relation
      \item reflexiv-symmetrisch-transitive Reduktions-Relation
    \end{itemize}
\end{itemize}

\paragraph{Verzweigung}
\label{par:verzweigung}

\begin{itemize}
  \item endliche Verzweigung: ein Ersetzungs-System $(M, \rightarrow)$ heißt
    \begin{description}
      \item[deterministisch,] wenn es zu jedem Element höchstens einen
        unmittelbaren Nachfolger gibt. Das ist äquivalent mit der
        Rechtseindeutigkeit der Relation.
      \item[endlich verzweigt,] wenn jedes Element $a \in M$ höchstens endlich
        viele unmittelbare Nachfolger hat, d.\,h.\ die Menge $\{b \mid a
        \rightarrow b\}$ ist endlich.
    \end{description}

  \item Lemma von \textsc{König}: sei $G$ ein zusammenhängender Graph mit
    unendlich vielen Knoten. Jeder Knoten habe nur endlich viele Kanten. Dann
    ist jeder Knoten Teil eines unendlich langen, einfachen Pfads im Graph.
\end{itemize}

\paragraph{Termination}
\label{par:termination}

\begin{itemize}
  \item Terminations-Eigenschaften: sei $(M, \rightarrow)$ ein
    Ersetzungs-System. Das Element $a \in M$ heißt
    \begin{description}
      \item[irreduzibel,]  wenn es kein $b \in M$ gibt, für das $a \rightarrow
        b$ gilt.
      \item[terminierend] oder \textsc{Noether}sch, wenn es zu $a$ keine
        unendliche Kette von Reduktionen gibt, wenn es also keine $m_1, m_2,
        \dots \in M$ gibt, mit $a \rightarrow m_1 \rightarrow m_2 \rightarrow
        \dots$.
      \item[beschränkt,] wenn es eine natürliche Zahl $L$ gibt, dass jede
        Reduktionskette von $a$ eine Länge kleiner als $L$ hat.
    \end{description}

    Das Ersetzungs-System selber heißt
    \begin{description}
      \item[terminierend] oder \textsc{Noether}sch, wenn es keine unendliche
        Kette von Reduktionen gibt.
      \item[lokal beschränkt] oder in jedem Element beschränkt, wenn jedes
        Element $a \in M$ beschränkt ist.
      \item[beschränkt] oder global beschränkt, wenn es eine natürliche Zahl $L$
        gibt, sodass für jedes Element $a \in M$ jede Reduktionskette von $a$
        eine Länge kleiner als $L$ hat.
    \end{description}

  \item Terminations-Eigenschaften: für ein einzelnes Element gelten folgende
    Zusammenhänge:
    \begin{enumerate}
      \item Ist ein Element beschränkt, dann ist es auch \textsc{Noether}sch.
      \item Ist ein Element \textsc{Noether}sch, dann muss es deshalb nicht
        beschränkt sein.
    \end{enumerate}

  \item Für ein Ersetzungs-System gilt:
    \begin{align*}
      \text{Global beschränkt} \Rightarrow \text{Lokal beschränkt} \Rightarrow
      \textsc{Noether}\text{sch}
    \end{align*}

  \item Variante und Invariante: sei $(M, \rightarrow)$ ein Ersetzungs-System.
    Eine Funktion $f : M \rightarrow W$ in eine beliebige Menge $W$ heißt eine
    Invariante des Ersetzungs-Systems, wenn ihre Funktionswerte längs der
    Reduktionen invariant (= unverändert) bleibt, d.\,h.\ wenn gilt:
    \begin{align*}
      \forall x, y \in M: x \rightarrow y \Rightarrow f(x) = f(y)
    \end{align*}
    Eine Funktion $f : M \rightarrow \N$ heißt eine (abnehmende) Variante des
    Ersetzungs-Systems, wenn ihre Funktionswerte längs der Reduktionen abnehmen,
    d.\,h.\ wenn gilt:
    \begin{align*}
      \forall x, y \in M: x \rightarrow y \Rightarrow f(x) > f(y)
    \end{align*}

  \item Terminationsbeweis durch Varianten-Funktion: gibt es zu einem
    Ersetzungs-System $(S, \rightarrow)$ eine abnehmende Variante $f : S
    \rightarrow \N$, dann ist das Ersetzungs-System terminierend. Ist diese
    Variante zusätzlich als Funktion auf $S$ nach oben beschränkt, dann ist das
    Ersetzungs-System sogar (global) beschränkt.

  \item Termination endlich verzweigter Systeme: ein endlich verzweigtes
    Ersetzungs-System terminiert genau dann, wenn es lokal (also in jedem
    Element) beschränkt ist.

  \item Terminations-Hierarchie: im allgemeinen Fall sieht die Hierarchie der
    Terminations-Begriffe so aus:
    \begin{align*}
      \text{Global beschränkt} \Rightarrow \text{lokal beschränkt} \Rightarrow
      \text{terminierend}
    \end{align*}
    Für endlich verzweigte Systeme kollabiert die Hierarchie und ergibt
    \begin{align*}
      \text{Global beschränkt} \Rightarrow \text{lokal beschränkt/terminierend}
    \end{align*}
\end{itemize}

\paragraph{Konfluenz}
\label{par:konfluenz}

\begin{itemize}
  \item Konfluenz: sei $(M, \rightarrow)$ ein Ersetzungs-System. Ein Element $a
    \in M$ heißt
    \begin{description}
      \item[konfluent,] wenn für alle $b, c \in M$ mit $a \rightarrow^* b$ und
        $a \rightarrow^* c$ ein $d \in M$ existiert, für das $b \rightarrow^* d$
        und $c \rightarrow^* d$.
      \item[semi-konfluent,] wenn für alle $b, c \in M$ mit $a \rightarrow b$
        und $a \rightarrow^* c$ ein $d \in M$ existiert, für das $b
        \rightarrow^* d$ und $c \rightarrow^* d$.
      \item[lokal konfluent,] wenn für alle $b, c \in M$ mit $a \rightarrow b$
        und $a \rightarrow c$ ein $d \in M$ existiert, für das $b \rightarrow^*
        d$ und $c \rightarrow^* d$.
    \end{description}
    In allen diesen Fällen heißt $d$ ein gemeinsames Redukt von $b$ und $c$ und
    $(b,c)$ heißt ein kritisches Paar zu $a$.

    Das Ersetzungs-System $(M, \rightarrow)$ selber heißt
    \begin{description}
      \item[konfluent,] wenn jedes Element $m \in M$ konfluent ist.
      \item[semi-konfluent,] wenn jedes Element $m \in M$ semi-konfluent ist.
      \item[lokal konfluent,] wenn jedes Element $m \in M$ lokal konfluent ist.
    \end{description}

  \item Konfluenz-Eigenschaften: für jedes Ersetzungs-System $\Rc = (M,
    \rightarrow)$ gilt:
    \begin{enumerate}
      \item $\Rc$ konfluent $\Rightarrow \Rc$ semi-konfluent
        $\Rightarrow \Rc$ lokal konfluent.
      \item $\Rc$ semi-konfluent $\Rightarrow \Rc$
        konfluent.
      \item $\Rc$ lokal konfluent und terminierend $\Rightarrow
        \Rc$ semi-konfluent.
    \end{enumerate}

  \item \textsc{Church-Rosser} Eigenschaft: ein Ersetzungs-System $(M,
    \rightarrow)$ erfüllt die \textsc{Church-Rosser} Eigenschaft, wenn gilt:
    \begin{align*}
      \forall x, y \in M:
      x \leftrightarrow^* y \Rightarrow
      \exists z \in M:
      x \rightarrow^* z \land y \rightarrow^* z
    \end{align*}

  \item Ein Ersetzungs-System ist genau dann \textsc{Church-Rosser}, wenn es
    konfluent ist.

  \item Überblick über die Eigenschaften von Ersetzungs-Systemen:
    \begin{center}
      \begin{tabular}{c|c|c}
        Konfluenz & $\Rightarrow$ & \\
        $\Leftrightarrow$ & (immer) & \\
        Semi-Konfluenz & & Lokale Konfluenz\\
        $\Leftrightarrow$ & $\Leftarrow$ & \\
        \textsc{Church-Rosser} & (falls terminierend) &
      \end{tabular}
    \end{center}
\end{itemize}

\paragraph{Normalformen}
\label{par:normalformen}

\begin{itemize}
  \item Normalform: sei $(S, \rightarrow)$ ein Ersetzungs-System.
    \begin{itemize}
      \item Ein Element $n \in S$ heißt eine Normalform, genau dann wenn es
        irreduzibel ist.
      \item Ein Element $n \in S$ heißt eine Normalform des Elements $a \in S$,
        wenn $n$ eine Normalform ist und $a$ auf $n$ reduziert, d.\,h. $a
        \rightarrow^* n$.
      \item Das Ersetzungs-System selber heißt normalisierend, wenn es zu jedem
        Element $a \in S$ mindestens eine Normalform gibt.
      \item Ein Ersetzungs-System heißt konvergent, wenn es konfluent und
        terminierend ist.
    \end{itemize}

  \item Normalformen-Theorem:
    \begin{enumerate}
      \item \textbf{Existenz:} in einem terminierenden Ersetzungs-System $(S,
        \rightarrow)$ gibt es zu jedem Element mindestens eine Normalform.
        Anders gesagt: ein terminierendes Ersetzungs-System ist auch
        normalisierend.
      \item \textbf{Eindeutigkeit:} in einem konfluenten Ersetzungs-System $(S,
        \rightarrow)$ gibt es zu jedem Element höchstens eine Normalform. Das
        bedeutet: Normalformen sind, falls sie überhaupt existieren, eindeutig.
      \item \textbf{Existenz und Eindeutigkeit:} in einem konfluenten,
        terminierenden Ersetzungs-System gibt es zu jedem Element $s \in S$
        genau eine Normalform.
    \end{enumerate}

  \item Äquivalenz: sei $(S, \rightarrow)$ ein konvergentes Ersetzungs-System.
    Zwei Elemente $x, y \in S$ heißen äquivalent unter dem betrachteten
    Ersetzungs-System, $x \sim_{(S, \rightarrow)} y$, wenn eine der beiden
    äquivalenten Bedingungen erfüllt ist:
    \begin{enumerate}
      \item $x \leftrightarrow^* y$
      \item Die Normalform von $x$ ist gleich der Normalform von $y$.
    \end{enumerate}
\end{itemize}

\paragraph{Wort-Ersetzungs-Systeme}
\label{par:wort_ersetzungs_systeme}

\begin{itemize}
  \item Semi-\textsc{Thue} und \textsc{Thue} Systeme: ein Semi-\textsc{Thue}
    System ist ein Paar $(\Sigma, \mapsto)$ bestehend aus
    \begin{enumerate}
      \item einer endlichen Menge $\Sigma$, dem sogenannten Alphabet, und
      \item einer endlichen binären Relation $\mapsto \ \subseteq \Sigma^*
        \times \Sigma^*$ auf dem Wortmonoid von $\Sigma^*$.
    \end{enumerate}

    Ein Paar $(u, v) \in \ \mapsto$, das in Relation steht, wird auch $u \mapsto
    v$ geschrieben und heißt eine Regel des Semi-\textsc{Thue} Systems.

    Ein \textsc{Thue} System ist ein Semi-\textsc{Thue} System, dessen Relation
    symmetrisch ist.

  \item Wort-Ersetzungs-System: ein Wort-Ersetzungs-System ist ein Paar
    $(\Sigma, \rightarrow)$ bestehend aus
    \begin{enumerate}
      \item einer endlichen Menge $\Sigma$, dem sogenannten Alphabet, und
      \item einer endlichen binären Relation $\rightarrow\ \subseteq \Sigma^*
        \times \Sigma^*$ auf dem Wortmonoid von $\Sigma^*$,
    \end{enumerate}
    welche unter Anfügen beliebiger Präfixe und Postfixe in ihrer Gültigkeit
    invariant bleibt, also die folgende Eigenschaft hat:
    \begin{align*}
      \forall x,z,u,v \in \Sigma^*:
      u \rightarrow v \Rightarrow xuz \rightarrow xvz
    \end{align*}

  \item Induzierte Relationen: sei $(\Sigma, \mapsto)$ ein Semi-\textsc{Thue}
    System. Dieses induziert dann weitere Relationen auf dem Wortmonoid:
    \begin{enumerate}
      \item Die Relation der einstufigen Ableitung $\rightarrow \ \subseteq
        \Sigma^* \times \Sigma^*$ ist definiert durch die Beziehung: $a
        \rightarrow b$ genau dann, wenn $\exists x,y,u,v \in \Sigma^*$ mit
        $a = x u y, b = x v y, u \mapsto v$.

        $(\Sigma, \rightarrow)$ ist also das vom Semi-\textsc{Thue} System
        erzeugte Wort-Ersetzungs-System.

      \item Die Relation der mehrstufigen Ableitung $\rightarrow^* \ \subseteq
        \Sigma^* \times \Sigma^*$ ist definiert durch die Beziehung: $a
        \rightarrow^* b$ genau dann, wenn $\exists s_0, s_1, \dots, s_n \in
        \Sigma^*$ mit $a = s_0 \rightarrow s_1 \rightarrow \dots \rightarrow s_n
        = b$.
    \end{enumerate}

  \item Überlappungs-Eigenschaften: wir betrachten die linken Seiten $l_1, l_2$
    von den Regeln $l_1 \mapsto r_1$ und $l_2 \mapsto r_2$ eines
    Semi-\textsc{Thue} Systems. Die linken Seiten können die folgenden, für
    Konfluenz kritischen Eigenschaften aufweisen:
    \begin{description}
      \item[Gleichheit:] Die Muster der Regeln sind gleich: $l_1 = l_2$
      \item[Enthalten-Sein:] Ein Muster ist in dem anderen enthalten:
        \begin{align*}
          \exists u,v \in \Sigma^*: l_1 = u l_2 v \ \lor \ l_2 = u l_1 v
        \end{align*}
      \item[Überlappung:] Ein Muster überlappt sich mit dem anderen Muster:
        \begin{align*}
          \exists a,b,c \in \Sigma^*, b \neq \varepsilon:
          (l_1 = ab \ \land \ l_2 = bc) \ \lor \ (l_1 = bc \ \land \ l_2 = ab)
        \end{align*}
    \end{description}

  \item Echtes Enthalten-Sein: ein Muster ist in dem anderen Muster echt
    enthalten, wenn es in dem Muster enthalten ist, aber von diesem verschieden
    ist.

  \item Echte Überlappung: ein Muster überlappt sich mit dem anderen Muster
    echt, wenn es mit diesem Muster überlappt, aber von diesem verschieden ist.

  \item Kritisches Paar: die zwei Regeln $l_1 \mapsto r_1$ und $l_2 \mapsto r_2$
    bilden ein kritisches Regel-Paar, wenn das Muster einer Regel mit dem Muster
    der anderen Regel identisch ist, mit ihm echt überlappt oder in ihm echt
    enthalten ist.

  \item Konfluenz-Theorem: wir betrachten ein Wort-Ersetzungs-System, das aus
    einem Semi-\textsc{Thue} System erzeugt wird. Dann gilt: wenn die kritischen
    Paare, die sich aus den kritischen Regel-Paaren des Semi-\textsc{Thue}
    Systems ergeben, ein gemeinsames Redukt haben, dann ist das
    Wort-Ersetzungs-System lokal konfluent.
\end{itemize}

\paragraph{Term-Ersetzungs-Systeme}
\label{par:term_ersetzungs_systeme}

\begin{itemize}
  \item Term-Ersetzungs-System: sei \textbf{Exp} eine Menge von Termen über
    einer Signatur $\Tc$ und einer Variablenmenge $\Vc$.

    Ein Term-Ersetzungs-System ist eine binäre Relation $\rightarrow \ \subseteq
    \textbf{Exp} \times \textbf{Exp}$, die unter Kontext-Anwendung und unter
    Substitutions-Anwendung abgeschlossen ist.

    Das bedeutet konkret:
    \begin{enumerate}
      \item Abgeschlossen unter Kontext: für jeden Kontext ${k[]}_p$, der zu einem
        Term $k$ an einer seiner Positionen $p$ gebildet werden kann, und für
        zwei Terme $t, u$ gilt:
        \begin{align*}
          t \rightarrow u \Rightarrow {k[t]}_p \rightarrow {k[u]}_p
        \end{align*}

      \item Abgeschlossen unter Substitution: für jede Substitution $\sigma$ und
        zwei Terme $t, u$ gilt:
        \begin{align*}
          t \rightarrow u \Rightarrow \sigma(t) \rightarrow \sigma(u)
        \end{align*}
    \end{enumerate}

  \item Von Regeln erzeugte Term-Ersetzungs-Systeme: sei \textbf{Exp} eine Menge
    von Termen. Für $i = 1, \dots, n$ seien die Regeln $l_i \mapsto r_i$
    vorgegeben, genauer gesagt: es ist eine endliche Relation $\mapsto \
    \subseteq \textbf{Exp} \times \textbf{Exp}$ vorgegeben. Das von der Relation
    $\mapsto$ erzeugte Term-Ersetzungs-System $\rightarrow \ \subseteq
    \textbf{Exp} \times \textbf{Exp}$ ist nun durch einen der folgenden
    äquivalenten Ansätze definiert:
    \begin{enumerate}
      \item $\rightarrow$ ist das Kleinste aller Term-Ersetzungs-Systeme
        $\Gamma$, in denen für jedes $i$ die Reduktion $l_i \Gamma r_i$ gilt.

      \item $\rightarrow$ ist der Durchschnitt aller Term-Ersetzungs-Systeme
        $\Gamma$, in denen für jedes $i$ die Reduktion $l_i \Gamma r_i$ gilt.

      \item $v \rightarrow w$ gelte genau dann, wenn es eine Substitution
        $\sigma$ gibt, eine Regel $l = l_i \mapsto r_i = r$ und eine Position
        $p$ zum Term $v$, so dass gilt:
        \begin{align*}
          {v |}_p = \sigma(l) \qquad w = {v[\sigma(r)]}_p
        \end{align*}
    \end{enumerate}

    Theoretische Vorgehensweise:
    \begin{enumerate}
      \item Suche einen Teilterm ${v |}_p$ des Ausgangsterms $v$. Auf diesen
        Teilterm soll die Regel $l \mapsto r$ angewendet werden.

      \item Unifiziere die linke Seite $l$ der Regel durch die Substitution
        $\sigma$ mit dem Teilterm ${v |}_p$ des Ausgangsterms $\sigma(l) = {v
        |}_p$.

      \item Wende die Regeln an durch Auswertung der Substitution $\sigma$ auf
        die Regel $l \mapsto r$. Es ergibt sich die Reduktion ${v |}_p =
        \sigma(l) \rightarrow \sigma(r)$.

      \item Bette die Anwendung ein in den ursprünglichen Kontext. Wende dafür
        den Kontext ${v[]}_p$ oberhalb des Teilterms ${v |}_p$ auf beiden Seiten
        an. Es ergibt sich ${v[\sigma(l)]}_p \rightarrow {v[\sigma(r)]}_p$.
    \end{enumerate}

  \item Terminations-Lemma: für ein terminierendes Term-Ersetzungs-System
    $\rightarrow \ \subseteq \textbf{Exp} \times \textbf{Exp}$ gilt:
    \begin{enumerate}
      \item Die linke Seite einer Reduktion besteht niemals nur aus einer
        Variablen.
      \item Eine Reduktion führt keine neuen (auf der linken Seite noch nicht
        benutzten) Variablen ein. Genauer: bezeichnet $\textbf{Var}(t)$ die
        Menge der Variablen, die in einem Term auftreten und ist $t \rightarrow
        u$, dann gilt $\textbf{Var}(t) \supseteq \textbf{Var}(u)$.
    \end{enumerate}

  \item Kritisches Paar: ein kritisches Paar zu zwei Regeln $l \mapsto r$ und $s
    \mapsto t$ ist ein Paar von Termen, das auf die folgende Weise erhalten
    werden kann:
    \begin{enumerate}
      \item Trennung der Variablen: forme die Regeln so zu neuen Regeln um, dass
        die Variablenmengen der Regeln disjunkt sind. Das gelingt immer, da
        Regeln unter Substitution abgeschlossen sind.

      \item Nicht-variabler Teilterm: suche einen beliebigen (echten oder
        unechten) Teilterm ${s|}_p$ der linken Seite der einen Regel $s$, der
        aber keine Variable ist.

      \item Unifikation: bestimme den allgemeinsten Unifikator dieses Teilterms
        ${s|}_p$ und der linken Seite $l$ der anderen Regel. Dieser ist also
        eine Substitution $\sigma$ mit $\sigma(l) = \sigma({s|}_p)$.

      \item Regelanwendung: nun sind beide Regeln auf den Term $\sigma(s)$
        anwendbar und können unterschiedliche Ergebnisse liefern. Konkret:
        \begin{enumerate}
          \item Die Regel $s \mapsto t$ ist auf den Term $\sigma(s)$ direkt
            anwendbar. Sie macht daraus den Term $\sigma(t)$.

          \item Die Regel $l \mapsto r$ ist auf den entsprechenden Teilterm
            $\sigma({s|}_p)$ anwendbar, da dieser wegen $\sigma(l) =
            \sigma({s|}_p)$ mit dem Muster der Regel unifiziert werden kann. Die
            Regel macht aus dem Teilterm selber $\sigma(r)$. Der äußere Kontext
            $\sigma({s[\cdot]}_p)$ darf darauf angewendet werden und ergibt
            $(\sigma(s)){[\sigma(r)]}_p$.
        \end{enumerate}
    \end{enumerate}

    Das Paar $(\sigma(t), (\sigma(s)){[\sigma(r)]}_p)$, das man auf diese Art
    und Weise aus den Regeln $l \mapsto r$ und $s \mapsto t$ erhält, heißt ein
    kritisches Paar dieser beiden Regeln.

  \item Critical Pair Lemma (\textsc{Huet}): Ein von einer Menge von Regeln
    erzeugtes Term-Ersetzungs-System ist lokal konfluent genau dann, wenn jedes
    kritische Paar $(p, q)$ der Regelmenge geschlossen werden kann, es also (in
    mehreren Schritten) zu einem gemeinsamen Term reduziert: $p \rightarrow^* z$
    und $q \rightarrow^* z$.

  \item Lineare Terme: ein Term $p \in \textbf{Exp}$ heißt linear, wenn keine
    Variable mehr als einmal in dem Term auftaucht.

    Ein Term-Ersetzungs-System heißt links-linear, wenn es aus einer Menge von
    Reduktionsregeln erzeugt werden kann, bei der die linke Seite jeder Regel
    ein linearer Term ist.

  \item Orthogonal: ein Term-Ersetzungs-System heißt orthogonal, wenn es frei
    von kritischen Paaren und links-linear ist.

  \item Satz von \textsc{Rosen}: jedes orthogonale Term-Ersetzungs-System ist
    konfluent.
\end{itemize}

\paragraph{Rekursion, Reduktion, Evaluation}
\label{par:rekursion_reduktion_evaluation}

\begin{itemize}
  \item Reduktions-Strategie: sei $(\rightarrow, \textbf{Exp})$ ein
    Term-Ersetzungs-System.

    Eine (einschrittige) Reduktions-Strategie für $\rightarrow$ ist eine
    Abbildung $\rho: \textbf{Exp} \rightarrow \textbf{Exp}$, bei der für jeden
    Term $t \in \textbf{Exp}$ gilt:
    \begin{enumerate}
      \item Falls $t$ Normalform ist, dann gilt $\rho(t) = t$
      \item In allen anderen Fällen gilt $t \rightarrow \rho(t)$.
    \end{enumerate}

    Eine (mehrschrittige) Reduktions-Strategie für $\rightarrow$ ist eine
    Abbildung $\rho: \textbf{Exp} \rightarrow \textbf{Exp}$, bei der für jeden
    Term $t \in \textbf{Exp}$ gilt:
    \begin{enumerate}
      \item Falls $t$ Normalform ist, dann gilt $\rho(t) = t$
      \item In allen anderen Fällen gilt $t \rightarrow^+ \rho(t)$.
    \end{enumerate}

  \item Redex: sei $u \rightarrow v$ eine Reduktion im Term-Ersetzungs-System
    $\rightarrow \ \subseteq \textbf{Exp} \times \textbf{Exp}$.

    Die Position $p$ im Term $u$ heißt ein Redex der Reduktion $u \rightarrow
    v$, falls $u \prightarrow w$ und $v = u{[w]}_p$. Das bedeutet anschaulich,
    dass $u$ in der Position $p$ reduzierbar ist und $v$ aus $u$ gerade durch
    eine Reduktion des Teilterms an dieser Position entsteht.

    Die Position $p$ in $u$ heißt reduzierbar, wenn es eine Reduktion $u
    \rightarrow v$ gibt, in der $p$ ein Redex dieser Reduktion ist.

    Ein Redex heißt minimal, wenn es keine reduzierbaren (echten) Teilterme
    enthält.

    Ein Redex heißt maximal, wenn es nicht (echter) Teilterm eines reduzierbaren
    Terms ist.

  \item Wichtige einschrittige Strategien: eine einschrittige
    Reduktions-Strategie $\rho : \textbf{Exp} \rightarrow \textbf{Exp}$ für ein
    Term-Ersetzungs-System $\rightarrow \ \subseteq \textbf{Exp} \times
    \textbf{Exp}$ heißt
    \begin{description}
      \item[innermost,] wenn es zu jeder Reduktion $t \rightarrow \rho(t)$ die
        Möglichkeit gibt, diese als Reduktion eines minimalen Redex zu
        interpretieren.

      \item[outermost,] wenn es zu jeder Reduktion $t \rightarrow \rho(t)$ die
        Möglichkeit gibt, diese als Reduktion eines maximalen Redex zu
        interpretieren.
    \end{description}

    Zwei spezifische Familien einschrittiger Reduktions-Strategien sind
    besonders wichtig:
    \begin{description}
      \item[leftmost innermost Reduktions-Strategien] reduzieren stets die
        linkeste reduzierbare Position, die selber keine reduzierbaren Teilterme
        mehr enthält.
      \item[leftmost outermost Reduktions-Strategien] reduzieren stets die
        linkeste reduzierbare Position.
    \end{description}

  \item Wichtige mehrschrittige Strategien:
    \begin{description}
      \item[parallel innermost Reduktions-Strategien] reduzieren simultan alle
        reduzierbaren Terme, die selber keine reduzierbaren Terme enthalten

        Beispiel: $g(f(f(0, \underline{f}(0, 1)), f(\underline{f}(2, 0),
        \underline{f}(3,1))))$ bei einem Term-Ersetzungs-System, das durch
        Regeln der Form $f(x,y) \mapsto \dots$ erzeugt wird.

      \item[parallel outermost Reduktions-Strategien] reduzieren simultan alle
        reduzierbaren Terme, die nicht Teilterm eines reduzierbaren Terms sind.

        Beispiel: $g(\underline{f}(0, f(0, 1)), \underline{f}(f(2, 0), f(3,1)))$
        bei einem Term-Ersetzungs-System, das durch Regeln der Form $f(x,y)
        \mapsto \dots$ erzeugt wird.

      \item[free argument Reduktions-Strategien] reduzieren simultan alle
        reduzierbaren Terme, bei denen zumindest ein Teilterm nicht reduzierbar
        ist.

        Beispiel: $g(\underline{f}(0, \underline{f}(0, 1)), f(\underline{f}(2,
        0), \underline{f}(3,1)))$ bei einem Term-Ersetzungs-System, das durch
        Regeln der Form $f(x,y) \mapsto \dots$ erzeugt wird.

      \item[full substitution Reduktions-Strategien] reduzieren simultan alle
        reduzierbaren Terme.

        Beispiel: $g(\underline{f}(0, \underline{f}(0, 1)),
        \underline{f}(\underline{f}(2, 0), \underline{f}(3,1)))$ bei einem
        Term-Ersetzungs-System, das durch Regeln der Form $f(x,y) \mapsto \dots$
        erzeugt wird.
    \end{description}

  \item Eigenschaften von Reduktions-Strategien: sei $\rightarrow \ \subseteq
    \textbf{Exp} \times \textbf{Exp}$ ein Term-Ersetzungs-System. Die (ein- oder
    mehrschrittige) Reduktions-Strategie $\rho: \textbf{Exp} \rightarrow
    \textbf{Exp}$ heißt normalisierend, wenn für jeden Term $t \in
    \textbf{Exp}$, zu dem (mindestens) eine Normalform existiert, die Folge $t,
    \rho(t), \rho^2(t), \dots$ (mindestens) eine Normalform enthält.

  \item Normalisierende Strategien: parallel outermost und full substitution
    sind für orthogonale Systeme normalisierend.

  \item Evaluation von Funktionen:
    \begin{description}
      \item[strikte Auswertung (strict evaluation)] bedeutet: bevor mit der
        Auswertung eines funktionalen Ausdrucks begonnen wird, sind die Werte
        aller Teilausdrücke zu bestimmen. Das gilt selbst dann, wenn diese
        Teilausdrücke in der Berechnung des Ausdrucks gar nicht „benötigt“
        werden.

      \item[nicht-strikte, verzögerte Auswertung (delayed evaluation)] fordert:
        die Werte der Argumente einer Funktion, werden erst dann bestimmt, wenn
        diese Argument in der Berechnung der Funktion „tatsächlich benötigt“
        wird. Dabei regelt die Semantik der spezifischen Programmiersprache, was
        mit „tatsächlich benötigt“ genau gemeint ist.

        Verzögerte Auswertung erlaubt die Beschreibung etlicher unendlicher
        Datenstrukturen, da diese erst dann (teilweise) aufgebaut werden, sobald
        die entsprechenden Komponenten benötigt werden. Die unendliche Struktur
        wird also nicht tatsächlich, sondern nur virtuell aufgebaut.
    \end{description}

  \item Strikte und verzögerte Auswertung ist eine Eigenschaft der Auswertung
    einer Funktionsbeschreibung und keine Eigenschaft der Funktion selbst.
\end{itemize}

\subsubsection{Semantik einfacher Sprachen}
\label{ssub:semantik_einfacher_sprachen}

\paragraph{Die Schleifensprache LOOP}
\label{par:die_schleifensprache_loop}

\begin{itemize}
  \item Grammatik von \textsc{Loop}:
    \begin{align*}
      \texttt{<Aexp>} \quad \rightarrow \quad
        & \texttt{<Num> | <Var> |}\\
        & \texttt{(<Aexp> + <Aexp>) | (<Aexp> - <Aexp>) |}\\
        & \texttt{(<Aexp> * <Aexp>)}\\
      \texttt{<Bexp>} \quad \rightarrow \quad
        & \texttt{T | F |}\\
        & \texttt{(<Aexp> = <Aexp>) | (<Aexp> <= <Aexp>) |}\\
        & \texttt{(<Bexp> AND <Bexp>) | (<Bexp> OR <Bexp>) |}\\
        & \texttt{NOT (<Bexp>)}\\
      \texttt{<Stm>} \quad \rightarrow \quad
        & \texttt{<Var> := <Aexp> |}\\
        & \texttt{SKIP |}\\
        & \texttt{( <Stm> ; <Stm> ) |}\\
        & \texttt{IF <Bexp> THEN <Stm> ELSE <Stm> FI |}\\
        & \texttt{LOOP <Aexp> DO <Stm> OD}\\
    \end{align*}

  \item Semantik der Sprache \textsc{Loop}:
    aus Sicht der formalen Sprachen ist dies eine kontextfreie Grammatik mit den
    Nichtterminalen \texttt{<Aexp>}, \texttt{<Bexp>}, \texttt{<Stm>},
    \texttt{<Num>} und \texttt{<Var>}. Uns interessieren jetzt jedoch nicht die
    syntaktischen Aspekte der Sprache, sondern die semantischen (also welche
    Bedeutung wir den einzelnen Elementen der Sprache zuschreiben).

    Die Nichtterminale führen uns zu fünf syntaktischen Kategorien, für die
    jeweils eine Interpretation angegeben werden soll:
    \begin{itemize}
      \item Variablensymbole
      \item Konstantensymbole
      \item \textsc{Bool}sche Ausdrücke
      \item arithmetische Ausdrücke
      \item Anweisungen (bzw. Statements)
    \end{itemize}

    Im Abschnitt~\nameref{par:zustande} (\ref{par:zustande}) haben wir schon den
    Ansatz über die Interpretation von Variablen kennengelernt. Daraus ergibt
    sich:
    \begin{align*}
      \llbracket \ \rrbracket_{\Vc}: \quad
        \textbf{Var} \rightarrow
          \big[
            \left[ \textbf{Var} \rightarrow \Z \right]
            \rightarrow \Z
          \big]
    \end{align*}
    Die Interpretation numerischer Konstanten kann man einfach oder konsistent
    mit den anderen Interpretationen festlegen:
    \begin{align*}
      \llbracket \ \rrbracket_{\Nc}: \quad &
        \textbf{Num} \rightarrow \Z\\
      \llbracket \ \rrbracket_{\Nc}: \quad &
        \textbf{Num} \rightarrow
          \big[
            \left[ \textbf{Var} \rightarrow \Z \right]
            \rightarrow \Z
          \big]
    \end{align*}
    Analog folgt die Interpretation für \textsc{Bool}sche und arithmetische
    Ausdrücke:
    \begin{align*}
      \llbracket \ \rrbracket_{\Bc}: \quad &
        \textbf{Bexp} \rightarrow
          \big[
            \left[ \textbf{Var} \rightarrow \Z \right]
            \rightarrow \{ \textbf{T}, \textbf{F} \}
          \big]\\
      \llbracket \ \rrbracket_{\Ac}: \quad &
        \textbf{Aexp} \rightarrow
          \big[
            \left[ \textbf{Var} \rightarrow \Z \right]
            \rightarrow \Z
          \big]
    \end{align*}
    Anweisungen werden den jeweiligen Zustand verändern und bekommen daher am
    besten die Interpretation als Zustandstransformator:
    \begin{align*}
      \llbracket \ \rrbracket_{\Sc}: \quad &
        \textbf{Stm} \rightarrow
          \big[
            \left[ \textbf{Var} \rightarrow \Z \right]
            \rightarrow
            \left[ \textbf{Var} \rightarrow \Z \right]
          \big]
    \end{align*}
    Mit der Konvention von $\Zc := \textbf{Var} \rightarrow \Z$ können wir das
    noch übersichtlicher schreiben:
    \begin{center}
      \begin{tabular}{lll}
        $\llbracket \ \rrbracket_{\Vc}$:
        & \textbf{Var}
        & $\rightarrow \ \left[ \Zc \rightarrow \Z \right]$\\
        $\llbracket \ \rrbracket_{\Nc}$:
        & \textbf{Num}
        & $\rightarrow \ \left[ \Zc \rightarrow \Z \right]$\\
        $\llbracket \ \rrbracket_{\Bc}$:
        & \textbf{Bexp}
        & $\rightarrow \ \left[ \Zc \rightarrow \{ \textbf{T}, \textbf{F} \} \right]$\\
        $\llbracket \ \rrbracket_{\Ac}$:
        & \textbf{Aexp}
        & $\rightarrow \ \left[ \Zc \rightarrow \Z \right]$\\
        $\llbracket \ \rrbracket_{\Sc}$:
        & \textbf{Stm}
        & $\rightarrow \ \left[ \Zc \rightarrow \Zc \right]$\\
      \end{tabular}
    \end{center}
\end{itemize}

\paragraph{Die Bedingungssprache WHILE}
\label{par:die_bedingungssprache_while}

\begin{itemize}
  \item Jetzt wird’s spannend, weil die Situation eintreten kann, dass das
    Programm nicht terminiert. Wir geben vier verschiedene (aber äquivalente)
    Semantiken an:
    \begin{description}
      \item[rekursive Semantik] beschreibt ein Programm als einen partiell
        definierten Zustandstransformator, der aus einem
        \textcolor{myred}{Anfangszustand} einen \textcolor{myblue}{Endzustand}
        macht:
        \begin{align*}
          \llbracket \ \rrbracket_{\Sc}:
          \textbf{Stm} \rightarrow
          \Big[
            \textcolor{myred}{\big[ \textbf{Var} \rightarrow \Z \big]}
            \rightharpoonup
            \textcolor{myblue}{\big[ \textbf{Var} \rightarrow \Z \big]}
          \Big]
        \end{align*}

      \item[Continuation Semantik] beschreibt ein Programm als eine totale
        Funktion, die einen \textcolor{myred}{Zustand} in einen
        \textcolor{myblue}{Zustand} und eine \textcolor{mygreen}{Continuation}
        abbildet:
        \begin{align*}
          \llbracket \ \rrbracket_{\Cc}:
          \textbf{Stm} \rightarrow
          \Big[
            \textcolor{myred}{\big[ \textbf{Var} \rightarrow \Z \big]}
            \rightarrow
            \textcolor{myblue}{\big[ \textbf{Var} \rightarrow \Z \big]}
            \times
            \textcolor{mygreen}{\textbf{Stm}}
          \Big]
        \end{align*}

      \item[natürliche Semantik] beschreibt ein Programm als eine Relation, die
        ausdrückt, wie ein Programm auf einen \textcolor{myred}{Zustand} wirkt
        und sich daraus unter Umständen ein \textcolor{myblue}{Endzustand}
        ergeben kann:
        \begin{align*}
          \rightarrow \ \subseteq
          \Big(
          \textbf{Stm}
          \times
          \textcolor{myred}{\big[ \textbf{Var} \rightarrow \Z \big]}
          \Big)
          \times
          \textcolor{myblue}{\big[ \textbf{Var} \rightarrow \Z \big]}
        \end{align*}

      \item[strukturelle Semantik] beschreibt ein Programm wie die natürliche
        Semantik, nur dass auf der rechten Seite neben einem
        \textcolor{myblue}{Zustand} auch noch eine
        \textcolor{mygreen}{Continuation} plus \textcolor{myblue}{Zustand}
        möglich ist:
        \begin{align*}
          \rightarrow \ \subseteq
          \Big(
          \textbf{Stm}
          \times
          \textcolor{myred}{\big[ \textbf{Var} \rightarrow \Z \big]}
          \Big)
          \times
          \Big(
          \textcolor{mygreen}{\textbf{Stm}}
          \times
          \textcolor{myblue}{\big[ \textbf{Var} \rightarrow \Z \big]}
          \Big)
          \cup
          \textcolor{myblue}{\big[ \textbf{Var} \rightarrow \Z \big]}
        \end{align*}
    \end{description}
\end{itemize}

\subsubsection{Denotationelle Semantik}
\label{ssub:denotationelle_semantik}

\begin{itemize}
  \item Domain: sei $D$ eine Menge und $\sqsubseteq \ \subseteq D \times D$ eine
    Ordnungsrelation (reflexiv, identitiv, transitiv).

    Eine (aufsteigende) $\omega$-Kette ist eine monoton wachsende Folge von
    Elemente in $D$ (also eine Funktion $a: \N_0 \rightarrow D$ bzw. Familie
    ${(a_n)}_{n \in \N_0}$) mit
    \begin{align*}
      a_0 \sqsubseteq a_1 \sqsubseteq a_2 \sqsubseteq \dots
    \end{align*}
    Eine Kette ist eine linear geordnete Menge.

    Sei $S \subseteq D$ eine Menge. Ein Element $d \in D$ heißt eine obere
    Schranke von $S$, wenn jedes Element $s$ von $S$ kleiner ist als $d$:
    \begin{align*}
      \forall s \in S: s \sqsubseteq d
    \end{align*}

    Eine Menge $T \subseteq D$ besitzt ein kleinstes Element $s$, wenn jedes
    andere Element in $T$ größer ist als $s$ und $s$ in $T$ liegt.

    Ein Element $d \in D$ heißt die kleinste obere Schranke von $S$, wenn die
    Menge aller oberen Schranken von $S$ ein kleinstes Element besitzt.

    Ein Domain ist ein Paar $(D, \sqsubseteq)$ aus einer Menge und einer
    Ordnungsrelation mit den folgenden beiden Eigenschaften:
    \begin{enumerate}
      \item Es gibt ein kleinstes Element $\bot \in D$. Das bedeutet:
        \begin{align*}
          \exists \bot \in D:
            \forall d \in D:
              \bot \sqsubseteq d
        \end{align*}

      \item Jede Kette in $D$ besitzt eine kleinste obere Schranke in $D$.
    \end{enumerate}

    In einem Domain bezeichne $\sup\limits_{n \in \N_0}$ die kleinste obere
    Schranke einer aufsteigenden $\omega$-Kette $a_0, a_1, \dots$. Analog
    bezeichne $\sup \Kc$ die kleinste obere Schranke einer beliebigen Kette.

  \item Monotonie, Stetigkeit, Striktheit: seien $(A, \sqsubseteq_A)$ und $(B,
    \sqsubseteq_B)$ zwei Domains.

    Eine Funktion $f: A \rightarrow B$ heißt
    \begin{description}
      \item[monoton,] wenn gilt:
        \begin{align*}
          \forall a_1, a_2 \in A:
            a_1 \sqsubseteq_A a_2 \Rightarrow f(a_1) \sqsubseteq_B f(a_2)
        \end{align*}

      \item[stetig,] wenn für jede aufsteigende Kette ${(a_n)}_{n \in \N_0}$:
        \begin{align*}
          f \left( \sup\limits_{n \in \N_0} (a_n) \right)
          =
          \sup\limits_{n \in \N_0} \left( f (a_n) \right)
        \end{align*}

      \item[strikt,] wenn sie das kleinste Element des ersten Domains auf das
        kleinste Element des zweiten Domains abbildet:
        \begin{align*}
          f ( \bot_A ) = \bot_B
        \end{align*}
    \end{description}
\end{itemize}

\subsubsection{Axiomatische Semantik}
\label{ssub:axiomatische_semantik}

\paragraph{Das WP-Kalkül}
\label{par:das_wp_kalkul}

\begin{itemize}
  \item Beispiel: weakest precondition finden:

    Angenommen wir haben folgendes C-Programm:
    \begin{lstlisting}[language=C]
      x = 3*y-2;
      if (x < 12) {
        y = 3*x-9;
      } else {
        y = x+6;
      }
      y = y-2;
    \end{lstlisting}
    Die postcondition sei $7 \leq y < 25$. Aus dieser leiten wir die weakest
    precondition her:
    \begin{align*}
      & \wpc(\texttt{x = 3*y-2;
          if (x < 12) \{
            y = 3*x-9;
          \} else \{
            y = x+6;
          \}
          \textcolor{myblue}{y = y-2;}},
        7 \leq y < 25
      )\\
      =
      & \wpc(\texttt{x = 3*y-2;
          if (x < 12) \{
            y = 3*x-9;
          \} else \{
            y = x+6;
          \}},
        7 \leq y-2 < 25
      )\\
      =
      & \wpc(\texttt{x = 3*y-2;
          if (x < 12) \{
            y = 3*x-9;
          \} else \{
            y = x+6;
          \}},
        9 \leq y < 27
      )\\
      =
      & \wpc(\texttt{x = 3*y-2;
          \textcolor{myblue}{if (x < 12) \{
            y = 3*x-9;
          \} else \{
            y = x+6;
          \}}},
        9 \leq y < 27
      )\\
      =
      & \wpc(\texttt{x = 3*y-2;},
        (x < 12 \land 9 \leq 3x-9 < 27)
        \lor
        (x \geq 12 \land 9 \leq x+6 < 27)
      )\\
      =
      & \wpc(\texttt{x = 3*y-2;},
        (x < 12 \land 6 \leq x < 12)
        \lor
        (x \geq 12 \land 3 \leq x < 21)
      )\\
      =
      & \wpc(\texttt{\textcolor{myblue}{x = 3*y-2;}},
        (x < 12 \land 6 \leq x < 12)
        \lor
        (x \geq 12 \land 3 \leq x < 21)
      )\\
      =
      & (3y-2 < 12 \land 6 \leq 3y-2 < 12)
        \lor
        (3y-2 \geq 12 \land 3 \leq 3y-2 < 21)
      \\
      =
      & \left(y < \frac{14}{3} \land \frac{8}{3} \leq y < \frac{14}{3}\right)
        \lor
        \left(y \geq \frac{14}{3} \land \frac{5}{3} \leq y < \frac{23}{3}\right)
      \\
      =
      & \left(
          \textcolor{myred}{y < \frac{14}{3}}
            \land
          \frac{8}{3} \leq \textcolor{myred}{y < \frac{14}{3}}
        \right)
        \lor
        \underbrace{%
          \left(
            y \geq \frac{14}{3}
            \land
            \frac{5}{3} \leq y < \frac{23}{3}
          \right)
        }_{%
          \frac{14}{3} \leq y < \frac{23}{3}
        }
      \\
      =
      & \left(
          \frac{8}{3} \leq y < \frac{14}{3}
        \right)
        \lor
        \left(
          \frac{14}{3} \leq y < \frac{23}{3}
        \right)
      \\
      = & \left( \frac{8}{3} \leq y < \frac{23}{3} \right)
    \end{align*}
\end{itemize}

\section{Übungsserien}

\subsection{Komplexität und Formale Sprachen}
\label{sub:komplexitat_und_formale_sprachen}

\subsubsection{Serie 1}
\label{sub:serie_1}

\input{kfs_serie_01}


\subsubsection{Serie 2}
\label{sub:serie_2}

\input{kfs_serie_02}


\subsubsection{Serie 3}
\label{sub:serie_3}

\input{kfs_serie_03}


\subsubsection{Serie 4}
\label{sub:serie_4}

\input{kfs_serie_04}


\subsubsection{Serie 5}
\label{sub:serie_5}

\input{kfs_serie_05}


\subsubsection{Serie 6}
\label{sub:serie_6}

\input{kfs_serie_06}


\subsubsection{Serie 7}
\label{sub:serie_7}

\input{kfs_serie_07}


\subsubsection{Serie 8}
\label{sub:serie_8}

\input{kfs_serie_08}


\subsubsection{Serie 9}
\label{sub:serie_9}

\input{kfs_serie_09}


\subsubsection{Serie 10}
\label{sub:serie_10}

\input{kfs_serie_10}

\subsection{Semantik}
\label{sec:semantik}

\subsubsection{Übung 243}
\label{ssub:uebung_243}

Das Ersetzungs-System ist
\begin{itemize}
  \item nicht terminierend
  \item nicht beschränkt
  \item konfluent $\Rightarrow$ semi-konfluent $\Rightarrow$ lokal konfluent
  \item nicht normalisierend
  \item nicht konvergent
\end{itemize}

Der irreflexive Kern ist
\begin{itemize}
  \item terminierend
  \item nicht beschränkt
  \item konfluent $\Rightarrow$ semi-konfluent $\Rightarrow$ lokal konfluent
  \item normalisierend
  \item konvergent (weil es konfluent und terminierend ist)
\end{itemize}

\begin{thebibliography}{9}

\bibitem{hopcroft2011}
  Hopcroft, John E., Rajeev Motwani, and Jeffrey D. Ullman,
  \emph{Einführung in Automatentheorie, Formale Sprachen und Berechenbarkeit},
  Pearson Deutschland GmbH,
  2011.

\end{thebibliography}

\end{document}
